# Домашнее задание к занятию "`Репликация и масштабирование. Часть 2`" - `Хавилов Виталий`

---

### Задание 1

Опишите основные преимущества использования масштабирования методами:

`активный master-сервер и пассивный репликационный slave-сервер;`
- Создание реплики увеличивает доступность(отказоустойчивость) системы, данных хранятся дополнительно в отдельном контейнере/ноде, производительность - возможно чтение с реплики, тем самым не использовать ресурсы мастера


`master-сервер и несколько slave-серверов;`
- такие же как в случае master-сервер и пассивный репликационный slave-сервер с дополнительными преимуществами, такими как доп исбыточность ( у нас несколько копий на инстансах) и доп масштабированность
активный сервер со специальным механизмом репликации — distributed replicated block device (DRBD); - DRBD синхронизирует данные на нескольких узлах в режиме реального времени обеспечивая быстрое восстановление при сбое одного узла, использует механизм зеркалирования блоков, обеспечивая минимальные задержки записи данных, совместим с различными решениями для кластеризации, обеспечивая высокую доступность и масштабируемость
SAN-кластер - возможно добавлять СХД на базе iscsi, FC. сеть может достигать скорость до 128гбит по FC, обеспечивает централизованное хранилище данных, доступное для всех серверов в кластере, фабрике, масштабируемость, доступность - все на вышем уровне



---

### Задание 2

Разработайте план для выполнения горизонтального и вертикального шаринга базы данных.
База данных состоит из трёх таблиц:

Попробую разобраться со шардингом для наших трех таблиц. Честно говоря, сначала путал горизонтальный и вертикальный шардинг.

Как я понял шардинг:

`Вертикальный - это когда таблицы по разным базам раскидываем`
`Горизонтальный - это когда одну таблицу по разным серверам размазываем`

Моя архитектура:
Вертикальное разделение:

```

user_service (отдельная БД)
├── users (основная таблица)
├── user_profiles (доп инфа)
└── user_sessions (сессии)

catalog_service (другая БД)  
├── books (книги)
├── authors (авторы)
└── categories (категории)

shop_service (третья БД)
├── shops (магазины)
├── inventory (остатки)
└── employees (сотрудники)

```
Горизонтальное разделение:

`Для users решил делить по ID:

Четные ID -> Шард 1

Нечетные ID -> Шард 2
(простое правило, чтобы не запутаться)`

`Для books - по жанрам:

Художественная литература -> Шард 1

Нехудожественная -> Шард 2`

`Для shops - по регионам:

Азия -> Шард 1

Европа -> Шард 2`

Нарисовал схему как понял:

```
┌─────────────────┐
│   Наше приложение  │
│   (шард-роутер)    │
└─────────┬───────┘
          │
    ┌─────┴─────┐
    │   Прокси  │
    │ (определяет │
    │  куда слать) │
    └─────┬─────┘
          │
    ┌─────┴─────────────┐
    │     Шард 1        │
    ├───────────────────┤
    │ user_service      │
    │ (четные ID)       │
    │ catalog_service   │
    │ (худ. литература) │
    │ shop_service      │
    │ (Азия)            │
    │                   │
    │ Master (запись)   │
    │ Slave (чтение)    │
    └───────────────────┘
          │
    ┌─────┴─────────────┐
    │     Шард 2        │
    ├───────────────────┤
    │ user_service      │
    │ (нечетные ID)     │
    │ catalog_service   │
    │ (нехуд. лит.)     │
    │ shop_service      │
    │ (Европа)          │
    │                   │
    │ Master (запись)   │
    │ Slave (чтение)    │
    └───────────────────┘

```

Как это будет работать:
`Master-серверы:`

Принимают все запросы на запись (INSERT, UPDATE, DELETE)

Реплицируют данные на свои slave-серверы

Работают в режиме чтение+запись

`Slave-серверы:`

Только для чтения (SELECT запросы)

Можно делать аналитику, отчеты - не мешая основной работе

Если master "упал", можно его заменить

`Прокси-роутер:`

Смотрит на ключ шардинга (ID пользователя, жанр книги, регион магазина)

Решает, на какой шард отправить запрос

Для пользователей: четный ID -> шард 1, нечетный -> шард 2

Почему так сделал:
`Горизонтальное разделение нужно, чтобы:`

Нагрузка распределялась между серверами

Можно было масштабироваться при росте данных

`Вертикальное разделение:`

Каждая сущность в своей БД - проще управлять

Не мешают друг другу

Честно говоря, сначала хотел сделать как в примерах из лекций - отдельные базы для каждой таблицы, но потом понял, что так будет сложно. Сделал как выше - вроде логичнее.
